# ğŸ’»Comandos Ãºteis Git/GitHub



# ğŸ’»GIT

## ğŸ’»Estados

- Modificado (modified);
- Preparado (staged/index)
- Consolidado (comitted);

## ğŸ’»Ajuda

##### Geral

```
git help
```

##### Comando especÃ­fico

```
git help add
git help commit
git help <qualquer_comando_git>
```

## ğŸ’»ConfiguraÃ§Ã£o

### ğŸ’»Geral

As configuraÃ§Ãµes do GIT sÃ£o armazenadas no arquivo **.gitconfig** localizado dentro do diretÃ³rio do usuÃ¡rio do Sistema Operacional (Ex.: Windows: C:\Users\Documents and Settings\Leonardo ou *nix /home/leonardo).

As configuraÃ§Ãµes realizadas atravÃ©s dos comandos abaixo serÃ£o incluÃ­das no arquivo citado acima.

##### ğŸªSetar usuÃ¡rio

```
git config --global user.name "Leonardo Comelli"
```

##### ğŸªSetar email

```
git config --global user.email leonardo@software-ltda.com.br
```

##### ğŸªSetar editor

```
git config --global core.editor vim
```

##### ğŸªSetar ferramenta de merge

```
git config --global merge.tool vimdiff
```

##### ğŸªSetar arquivos a serem ignorados

```
git config --global core.excludesfile ~/.gitignore
```

##### ğŸªListar configuraÃ§Ãµes

```
git config --list
```

### ğŸ’»Ignorar Arquivos

Os nomes de arquivos/diretÃ³rios ou extensÃµes de arquivos listados no arquivo **.gitignore** nÃ£o serÃ£o adicionados em um repositÃ³rio. Existem dois arquivos .gitignore, sÃ£o eles:

- Geral: Normalmente armazenado no diretÃ³rio do usuÃ¡rio do Sistema Operacional. O arquivo que possui a lista dos arquivos/diretÃ³rios a serem ignorados por **todos os repositÃ³rios** deverÃ¡ ser declarado conforme citado acima. O arquivo nÃ£o precisa ter o nome de **.gitignore**.
- Por repositÃ³rio: Deve ser armazenado no diretÃ³rio do repositÃ³rio e deve conter a lista dos arquivos/diretÃ³rios que devem ser ignorados apenas para o repositÃ³rio especÃ­fico.





## ğŸ’»RepositÃ³rio Local

### ğŸ’»Criar novo repositÃ³rio

Para comeÃ§ar um projeto que ainda nÃ£o seja um repositÃ³rio (ou repo), o Git Init costuma ser o primeiro comando que vocÃª vai usar, pois vai precisar de um subdiretÃ³rio .git na raiz do seu projeto.

Esse comando cria um repositÃ³rio vazio ou transforma uma pasta que vocÃª jÃ¡ tem, e que nÃ£o estÃ¡ com controle de versÃ£o, em um repositÃ³rio.

```
git init
```

Com sua pasta de trabalho devidamente iniciada, Ã© hora de comeÃ§ar a preenchÃª-la.



### ğŸ’»Verificar estado dos arquivos/diretÃ³rios

### ğŸ’»Git status

O comando status do Git fornece algumas informaÃ§Ãµes sobre a *branch* em que vocÃª estiver no momento, como seu nome, se ela estÃ¡ atualizada em relaÃ§Ã£o Ã  master e quais arquivos foram alterados.

```
git status
```

### ğŸ’»Adicionar arquivo/diretÃ³rio (staged area)

##### ğŸªAdicionar um arquivo em especÃ­fico

```
git add meu_arquivo.txt
```

##### ğŸªAdicionar um diretÃ³rio em especÃ­fico

```
git add meu_diretorio
```

##### ğŸªAdicionar todos os arquivos/diretÃ³rios

```
git add .	
```

##### ğŸªAdicionar um arquivo que esta listado no .gitignore (geral ou do repositÃ³rio)

```
git add -f arquivo_no_gitignore.txt
```



### ğŸ’»Comitar arquivo/diretÃ³rio

Este comando Ã© como definir um ponto de verificaÃ§Ã£o no processo de desenvolvimento, para o qual vocÃª pode voltar mais tarde, se necessÃ¡rio.

##### ğŸªComitar um arquivo

```
git commit meu_arquivo.txt
```

##### ğŸªComitar vÃ¡rios arquivos

```
git commit meu_arquivo.txt meu_outro_arquivo.txt
```

##### ğŸªComitar informando mensagem

```
git commit meuarquivo.txt -m "minha mensagem de commit"
```



### ğŸ’»Os commits

O segundo atalho que iremos criar serÃ¡ para o nosso processo de *commit*.

Nesta configuraÃ§Ã£o utilizaremos os parÃ¢metros **â€“all**, que adiciona todos os arquivos para o *staged* de mudanÃ§as, e logo em seguida **(&&)** executa o *commit* com o parÃ¢metro **-m** que nos permite incluir a mensagem descritiva do nosso *commit*.

```
c = !git add --all && git commit -m
```

Lembre-se que caso vocÃª nÃ£o queira adicionar todos os arquivos alterados para o processo de commit, deve-se incluir individualmente os arquivos que desejamos com o comando tradicional **git add [nome do arquivo]** e depois executarmos o comando **git commit -m â€œ[Mensagem Descritiva]â€**. Ou seja, o processo tradicional.



### ğŸ’»Remover arquivo/diretÃ³rio

##### ğŸªRemover arquivo

```
git rm meu_arquivo.txt
```

##### ğŸªRemover diretÃ³rio

```
git rm -r diretorio
```

### ğŸ’»Visualizar histÃ³rico

##### ğŸªExibir histÃ³rico

```
git log
```

##### ğŸªExibir histÃ³rico com diff das duas Ãºltimas alteraÃ§Ãµes

```
git log -p -2
```

##### ğŸªExibir resumo do histÃ³rico (hash completa, autor, data, comentÃ¡rio e qtde de alteraÃ§Ãµes (+/-))

```
git log --stat
```

##### ğŸªExibir informaÃ§Ãµes resumidas em uma linha (hash completa e comentÃ¡rio)

```
git log --pretty=oneline
```

##### ğŸªExibir histÃ³rico com formataÃ§Ã£o especÃ­fica (hash abreviada, autor, data e comentÃ¡rio)

```
git log --pretty=format:"%h - %an, %ar : %s"
```

- %h: AbreviaÃ§Ã£o do hash;
- %an: Nome do autor;
- %ar: Data;
- %s: ComentÃ¡rio.

Verifique as demais opÃ§Ãµes de formataÃ§Ã£o no [Git Book](http://git-scm.com/book/en/Git-Basics-Viewing-the-Commit-History)

##### ğŸªExibir histÃ³rio de um arquivo especÃ­fico

```
git log -- <caminho_do_arquivo>
```

##### ğŸªExibir histÃ³rico de um arquivo especÃ­fico que contÃªm uma determinada palavra

```
git log --summary -S<palavra> [<caminho_do_arquivo>]
```

##### ğŸªExibir histÃ³rico modificaÃ§Ã£o de um arquivo

```
git log --diff-filter=M -- <caminho_do_arquivo>
```

- O pode ser substituido por: Adicionado (A), Copiado (C), Apagado (D), Modificado (M), Renomeado (R), entre outros.

##### ğŸªExibir histÃ³rio de um determinado autor

```
git log --author=usuario
```

##### ğŸªExibir revisÃ£o e autor da Ãºltima modificaÃ§Ã£o de uma bloco de linhas

```
git blame -L 12,22 meu_arquivo.txt 
```

### ğŸ’»Desfazendo operaÃ§Ãµes

##### ğŸªDesfazendo alteraÃ§Ã£o local (working directory)

Este comando deve ser utilizando enquanto o arquivo nÃ£o foi adicionado na **staged area**.

```
git checkout -- meu_arquivo.txt
```

##### ğŸªDesfazendo alteraÃ§Ã£o local (staging area)

Este comando deve ser utilizando quando o arquivo jÃ¡ foi adicionado na **staged area**.

```
git reset HEAD meu_arquivo.txt
```

Se o resultado abaixo for exibido, o comando reset *nÃ£o* alterou o diretÃ³rio de trabalho.

```
Unstaged changes after reset:
M	meu_arquivo.txt
```

A alteraÃ§Ã£o do diretÃ³rio pode ser realizada atravÃ©s do comando abaixo:

```
git checkout meu_arquivo.txt
```

## ğŸ’»ERepositÃ³rio Remoto

### ğŸ’»Exibir os repositÃ³rios remotos

```
git remote

git remote -v
```

### ğŸ’»Vincular repositÃ³rio local com um repositÃ³rio remoto

```
git remote add origin git@github.com:leocomelli/curso-git.git
```

### ğŸ’»Exibir informaÃ§Ãµes dos repositÃ³rios remotos

```
git remote show origin
```

### ğŸ’»Renomear um repositÃ³rio remoto

```
git remote rename origin curso-git
```

### ğŸ’»Desvincular um repositÃ³rio remoto

```
git remote rm curso-git
```

### ğŸ’»Enviar arquivos/diretÃ³rios para o repositÃ³rio remoto

O primeiro **push** de um repositÃ³rio deve conter o nome do repositÃ³rio remoto e o branch.

ApÃ³s confirmar as alteraÃ§Ãµes, a prÃ³xima coisa que vocÃª deseja fazer Ã© enviar as alteraÃ§Ãµes para o servidor remoto.

O comando **git push** envia e salva suas confirmaÃ§Ãµes no repositÃ³rio remoto.

```
git push -u origin master
```

Os demais **pushes** nÃ£o precisam dessa informaÃ§Ã£o

```
git push
```

### ğŸ’»Atualizar repositÃ³rio local de acordo com o repositÃ³rio remoto

O comando **git pull** Ã© usado para obter atualizaÃ§Ãµes do repositÃ³rio remoto. O comando de pull depende do referencial de onde ele foi feito, ou seja, um git pull feito da sua mÃ¡quina vai puxar informaÃ§Ãµes do repositÃ³rio original para ela.

Mas um git pull feito a partir do repositÃ³rio original vai puxar as informaÃ§Ãµes da sua mÃ¡quina. Percebe?

Este comando Ã© uma combinaÃ§Ã£o de *git fetch* (baixa as alteraÃ§Ãµes do repositÃ³rio remoto mas nÃ£o mescla elas com o seu) e *git merge* (que mescla tudo junto), o que significa que, quando usamos o **git pull**, ele recebe as atualizaÃ§Ãµes do repositÃ³rio remoto (**git fetch**) e aplica imediatamente as alteraÃ§Ãµes mais recentes no seu local (**git merge**).

##### ğŸªAtualizar os arquivos no branch atual

```
git pull
```

##### ğŸªBuscar as alteraÃ§Ãµes, mas nÃ£o aplica-las no branch atual

```
git fetch
```

### ğŸ’»Clonar um repositÃ³rio remoto jÃ¡ existente

```
git clone git@github.com:leocomelli/curso-git.git
```

### ğŸ’»Tags

##### ğŸªCriando uma tag leve

```
git tag vs-1.1
```

##### ğŸªCriando uma tag anotada

```
git tag -a vs-1.1 -m "Minha versÃ£o 1.1"
```

##### ğŸªCriando uma tag assinada

Para criar uma tag assinada Ã© necessÃ¡rio uma chave privada (GNU Privacy Guard - GPG).

```
git tag -s vs-1.1 -m "Minha tag assinada 1.1"
```

##### ğŸªCriando tag a partir de um commit (hash)

```
git tag -a vs-1.2 9fceb02
```

##### ğŸªCriando tags no repositÃ³rio remoto

```
git push origin vs-1.2
```

##### ğŸªCriando todas as tags locais no repositÃ³rio remoto

```
git push origin --tags
```

### ğŸ’»Branches

O **master** Ã© o branch principal do GIT.

O **HEAD** Ã© um ponteiro *especial* que indica qual Ã© o branch atual. Por padrÃ£o, o **HEAD** aponta para o branch principal, o **master**.

##### ğŸªCriando um novo branch

```
git branch bug-123
```

##### ğŸªTrocando para um branch existente

```
git checkout bug-123
```

Neste caso, o ponteiro principal **HEAD** esta apontando para o branch chamado bug-123.

##### ğŸªCriar um novo branch e trocar

```
git checkout -b bug-456
```

##### ğŸªVoltar para o branch principal (master)

```
git checkout master
```

##### ğŸªResolver merge entre os branches

Quando vocÃª conclui o desenvolvimento em sua *branch* e tudo funciona bem, sem conflitos, a etapa final Ã© mesclar as *branches*, isso Ã© feito com o comando **git merge**.

Como falamos no tÃ³pico sobre git pull, esse comando vai mesclar, no seu repositÃ³rio local, todas as alteraÃ§Ãµes feitas.

```
git merge bug-123
```

Para realizar o *merge*, Ã© necessÃ¡rio estar no branch que deverÃ¡ receber as alteraÃ§Ãµes. O *merge* pode automÃ¡tico ou manual. O merge automÃ¡tico serÃ¡ feito em arquivos textos que nÃ£o sofreram alteraÃ§Ãµes nas mesmas linhas, jÃ¡ o merge manual serÃ¡ feito em arquivos textos que sofreram alteraÃ§Ãµes nas mesmas linhas.

A mensagem indicando um *merge* manual serÃ¡:

```
Automerging meu_arquivo.txt
CONFLICT (content): Merge conflict in meu_arquivo.txt
Automatic merge failed; fix conflicts and then commit the result.
```

##### ğŸªApagando um branch

```
git branch -d bug-123
```

##### ğŸªListar branches

###### Listar branches

```
git branch
```

###### ğŸªListar branches com informaÃ§Ãµes dos Ãºltimos commits

```
git branch -v
```

###### ğŸªListar branches que jÃ¡ foram fundidos (merged) com o **master**

```
git branch --merged
```

###### ğŸªListar branches que nÃ£o foram fundidos (merged) com o **master**

```
git branch --no-merged
```

##### ğŸªCriando branches no repositÃ³rio remoto

###### ğŸªCriando um branch remoto com o mesmo nome

```
git push origin bug-123
```

###### ğŸªCriando um branch remoto com nome diferente

```
git push origin bug-123:new-branch
```

##### ğŸªBaixar um branch remoto para ediÃ§Ã£o

```
git checkout -b bug-123 origin/bug-123
```

##### ğŸªApagar branch remoto

```
git push origin:bug-123
```

### ğŸ’»Rebasing

Fazendo o **rebase** entre um o branch bug-123 e o master.

```
git checkout experiment

git rebase master
```

Mais informaÃ§Ãµes e explicaÃ§Ãµes sobre o [Rebasing](http://git-scm.com/book/en/Git-Branching-Rebasing)

\###Stash

Para alternar entre um branch e outro Ã© necessÃ¡rio fazer o commit das alteraÃ§Ãµes atuais para depois trocar para um outro branch. Se existir a necessidade de realizar a troca sem fazer o commit Ã© possÃ­vel criar um **stash**. O Stash como se fosse um branch temporÃ¡rio que contem apenas as alteraÃ§Ãµes ainda nÃ£o commitadas.

##### ğŸªCriar um stash

```
git stash
```

##### ğŸªListar stashes

```
git stash list
```

##### ğŸªVoltar para o Ãºltimo stash

```
git stash apply
```

##### ğŸªVoltar para um stash especÃ­fico

```
git stash apply stash@{2}
```

Onde **2** Ã© o indÃ­ce do stash desejado.

##### ğŸªCriar um branch a partir de um stash

```
git stash branch meu_branch
```

### ğŸ’»Reescrevendo o histÃ³rico

##### ğŸªAlterando mensagens de commit

```
git commit --amend -m "Minha nova mensagem"
```

##### ğŸªAlterar Ãºltimos commits

Alterando os trÃªs Ãºltimos commits

```
git rebase -i HEAD~3
```

O editor de texto serÃ¡ aberto com as linhas representando os trÃªs Ãºltimos commits.

```
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added catfile
```

Altere para edit os commits que deseja realizar alteraÃ§Ãµes.

```
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added catfile
```

Feche o editor de texto.

Digite o comando para alterar a mensagem do commit que foi marcado como *edit*.

```
git commit â€“amend -m â€œNova mensagemâ€
```

Aplique a alteraÃ§Ã£o

```
git rebase --continue
```

**AtenÃ§Ã£o:** Ã‰ possÃ­vel alterar a ordem dos commits ou remover um commit apenas mudando as linhas ou removendo.

##### ğŸªJuntando vÃ¡rios commits

Seguir os mesmos passos acima, porÃ©m marcar os commtis que devem ser juntados com **squash*

##### ğŸªRemover todo histÃ³rico de um arquivo

```
git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
```

### ğŸ’»Bisect

O bisect (pesquisa binÃ¡ria) Ã© Ãºtil para encontrar um commit que esta gerando um bug ou uma inconsistÃªncia entre uma sequÃªncia de commits.

##### ğŸªIniciar pequinsa binÃ¡ria

```
git bisect start
```

##### ğŸªMarcar o commit atual como ruim

```
git bisect bad
```

##### ğŸªMarcar o commit de uma tag que esta sem o bug/inconsistÃªncia

```
git bisect good vs-1.1
```

##### ğŸªMarcar o commit como bom

O GIT irÃ¡ navegar entre os commits para ajudar a indentificar o commit que esta com o problema. Se o commit atual nÃ£o estiver quebrado, entÃ£o Ã© necessÃ¡rio marca-lo como **bom**.

```
git bisect good
```

##### ğŸªMarcar o commit como ruim

Se o commit estiver com o problema, entÃ£o ele deverÃ¡ ser marcado como **ruim**.

```
git bisect bad
```

##### ğŸªFinalizar a pesquisa binÃ¡ria

Depois de encontrar o commit com problema, para retornar para o *HEAD* utilize:

```
git bisect reset
```



[ğŸ”](https://emojiterra.com/pt/lupa-para-a-direita/)**InformaÃ§Ãµes extraÃ­das e editadas de:**

Lista de comandos Ãºteis do GIT [Raw](https://gist.github.com/leocomelli/2545add34e4fec21ec16/raw/c64848ecdf1ff78751d0a9906063091271790f48/git.md)https://gist.github.com/leocomelli/2545add34e4fec21ec16  Acesso em 15/02/2022

Comandos Git mais utilizados e como configurar https://blog.geekhunter.com.br/comandos-git-mais-utilizados/ Acesso em 15/02/2022